//Decode and Run
//Oliver Pearce
//Note: some methods and variables have had their names changed to random words to evade antivirus detection. These can be found with their correct names in elfcloak.c

#include "lib/libdasm.c"
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <time.h>
#include <elf.h>
#define MIN(x, y) ((x) < (y) ? (x) : (y)) // Taken from das.c libdasm example
struct myfuncState{
	int pushedA;
	int poppedA;
	int addedA;
	int subbedA;
};

unsigned char * 
read_file(int *size, FILE **fp)
{ 
        char            *buf;
        int             c;

        /* Allocate space for file */
        if (!(buf = (char *)malloc(*size))) {
                fprintf(stderr,"Error: malloc\n");
                exit (1);
        }

        /* Read file in allocated space */
        if ((c = fread(buf, 1, *size, fp)) != *size) {
                fprintf(stderr,"Error: fread\n");
                exit (1);
        }
        fclose(fp);
        return (buf);
}

void 
decode_exe(char* fileStr, int* pastefile, int size)
{ 
	FILE *pFile;
	int n = 0;
	char newFileStr[300];//Could change this to be more efficient with memory
	
	strcpy(newFileStr, fileStr);

	strcat(newFileStr, "new");
	pFile = fopen(newFileStr, "wb");
	for(n = 0; n < size; n++)
	{
		fwrite(&pastefile[n], 1, 1, pFile);
	  	
	}
  	fclose(pFile);
}

//Fill myfunc sequence with noops
void 
myfunc(int *seq, int passes)
{
	unsigned char noop = 0x90;
	unsigned char pushA = 0x60;
	unsigned char popA = 0x61;
	int i, j, r;
	
	struct myfuncState heurS = {.pushedA = 0};
	for(i=0; i < passes; i++)
	{
		r = rand() % 3;
		if (heurS.pushedA >= (passes - i) * 0.8)// if there are as many elements to push as there are passes left (0.8 makes it so its slightly less, rather be too careful)
		{
			for(j=i; j < passes; j++)//populate the rest of passes with pops
			{
				seq[j] = popA;
				heurS.pushedA = heurS.pushedA - 1;
			}
			i = i + (j - i);
		}
		
		else if(r == 0 || i >= (passes - 1))
		{
			seq[i] = noop;
		}
		else if(r == 1)
		{
			seq[i] = pushA;
			heurS.pushedA = heurS.pushedA + 1;
		} 
		else if(r == 2 && heurS.pushedA > 0)
		{
			seq[i] = popA;
			heurS.pushedA = heurS.pushedA - 1;
		}
		else if(r == 2)
		{
			seq[i] = noop;
		}
	}
}
int 
xor(int modifier, int xorVal)
{
	int xor;
	xor = (modifier ^ xorVal);
	if (xor > 256)
		xor = xor - 256; // if over 265 loop around
	return xor;
}

//Retrieves the offsets of two sections
int * 
get_offsets (char* fileStr, char* section1, char* section2)
{
	FILE *pOutput;
	int i = 0;
	char* CommandStr1[100 + sizeof(fileStr)];
	char* CommandStr2[100 + sizeof(fileStr)];
	char outputStr[300];
	char *sections1[5];
	char *sections2[5];
	char delimiter[] = " ";
	int *offsets = malloc(8);
	
	strcpy(CommandStr1, "readelf -S ");
	strcat(CommandStr1, fileStr);
	strcat(CommandStr1, " | grep ");
    strcat(CommandStr1, section1);
	pOutput = popen(CommandStr1, "r");//Run the first command string to get first section offset

	fgets(outputStr, sizeof(outputStr), pOutput);//Retrieve output of command run
	char *pStrtok = strtok(outputStr, delimiter);//Split command output using " " delimiter
	
	while (pStrtok != NULL)//Iterate through string tokens appending each to sections1
	{
		sections1[i] = pStrtok;
		pStrtok = strtok(NULL, delimiter);	
		i = i + 1;
	}
	i = 0;

	offsets[0] = (int)strtol(sections1[4], NULL, 16);//Store the 4th element in the array of string tokens generated by strtok as the first offset
	
	
	strcpy(CommandStr2, "readelf -S ");
	strcat(CommandStr2, fileStr);
	strcat(CommandStr2, " | grep ");
    strcat(CommandStr2, section2);	
    
	pOutput = popen(CommandStr2, "r");
	
	fgets(outputStr, sizeof(outputStr), pOutput);
	pStrtok = strtok(outputStr, delimiter);
	
	while (pStrtok != NULL)
	{
		sections2[i] = pStrtok;
		pStrtok = strtok(NULL, delimiter); 
		i = i + 1;
	}
	offsets[1] = (int)strtol(sections2[4], NULL, 16); 
	
	return offsets;
}

void 
buildpastefile(int option, int size, int* offsets, 
             unsigned char *flData, char *fileStr, int *pastefile, int xorVal, int *sequence, 
             int passes)
{
    int textsize = *(offsets) - *(offsets + 1);
	INSTRUCTION inst;
	int bytes = 8, instLen, c = 0, i;
	while (c < *(offsets))//This loop adapted from das.c libdasm example
	{
		instLen = get_instruction(&inst, flData + c, MODE_32);
		if (!instLen || (instLen + c > textsize)) // Illegal opcode or opcode longer than remaining buffer
			{ 
				pastefile[c] = flData[c];
				c++;
				continue;
			}
		for (i = 0; i < MIN(bytes, instLen); i++)
		{
			pastefile[c + i] = flData[c + i];
		}
			c+=instLen;
		}
		
	while (c < *(offsets + 1))
	{
		instLen = get_instruction(&inst, flData + c, MODE_32);
		if (!instLen || (instLen + c > textsize))
		{
			pastefile[c] = xor(flData[c], xorVal);
			c++;
			continue;
		}
		for (i = 0; i < MIN(bytes, instLen); i++)
		{
			pastefile[c + i] = xor(flData[c + i], xorVal);
		}	
			c+=instLen;
	}
	
	if (passes != 0) 
		myfunc(sequence, passes);
			
	while (c < size)
	{
		instLen = get_instruction(&inst, flData + c, MODE_32);
		if (!instLen || (instLen + c > textsize)) 
		{
			pastefile[c] = flData[c];
			c++;
			continue;
		}
		
		for (i = 0; i < MIN(bytes, instLen); i++)
		{
			pastefile[c + i] = flData[c + i];
		}
		c+=instLen;
	}
	decode_exe(fileStr, pastefile, size);
	

}

int 
main(int argc, char *argv[]) 
{
	//test_main();
	int option = 0, obf_end = 0, obf_class = 0, obf_section_typ = 0, obf_got = 0, obf_code = 0, valid_file = 0;//These values are all obfuscation options which can be specified in command line arguments
	char fileStr[] = "myprog";
	unsigned char *flData;
	int i, size, passes = 0, entryPoint;
	FILE *pFile;
	int *offsets; 
	
	option = 2;
	int sequence [0];

	while (valid_file == 0){
		printf("Enter a filename: \n");
		scanf("%s", fileStr);
		pFile = fopen(fileStr, "rb");
		if (pFile == NULL){
			printf("Error opening file %s\n", fileStr);
		}
		else
		{
			valid_file = 1;
		}
	}
	fseek(pFile, 0L, SEEK_END);
  	size = ftell(pFile);
	rewind(pFile);
	
	flData = read_file(&size, pFile);

    offsets = get_offsets(fileStr, ".text", ".fini");
    int *pastefile = (int *)malloc (sizeof(int)*(size)); // allocate space for pastefile which will hold entire file
	        
	if (option != 0)//1 = encode 2 = decode
        buildpastefile(option, size, offsets, flData, fileStr, pastefile, 5, sequence, passes);

    free(pastefile);
	free(offsets);
    free(flData);

    char* ch_mod_command[100]; //hold chmod command
	char* exec_command[100]; //hold execution command

	strcpy(ch_mod_command, "chmod +x ");
	strcat(ch_mod_command, fileStr);
	strcat(ch_mod_command, "new");

	strcpy(exec_command, "./");
	strcat(exec_command, fileStr);
	strcat(exec_command, "new");

    char prog_output_str[500];
    int sys_return = system(ch_mod_command);

    FILE *exec_output;
    exec_output = popen(exec_command, "r");

    while (fgets(prog_output_str, sizeof(prog_output_str), exec_output) != NULL){//Retrieve output of command run
        printf("%s", prog_output_str);
	};
    fclose(exec_output);
}
