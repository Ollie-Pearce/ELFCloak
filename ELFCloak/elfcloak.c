//////////////////////////////////////////////////
//						                        //
//						                        //
//	ELFCloak Obfuscation Framework              //
//		Oliver Pearce			                //
//						                        //
//////////////////////////////////////////////////
#include "lib/libdasm.c"
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <time.h>
#include <elf.h>
#include "elfcloak.h"
/////////////////////////////////////////////////ELFREVGO Techniques
#include "elfrevgo_techniques/obfuscate_class.c"
#include "elfrevgo_techniques/obfuscate_endianness.c"
#include "elfrevgo_techniques/obfuscate_got.c"
#include "elfrevgo_techniques/obfuscate_section_type.c"
/////////////////////////////////////////////////Code Level Techniques
#include "code_level_techniques/obfuscate_code.c"
/////////////////////////////////////////////////
#include "encoding_techniques/build_encoder.c"
/////////////////////////////////////////////////Libdasm
//#include "elfcloak_tests.h"

//this method adapted from the das example in libdasm
unsigned char * 
read_file(int *size, FILE **fp)
{ 
        char            *buf;
        int             c;

        /* Allocate space for file */
        if (!(buf = (char *)malloc(*size))) {
                fprintf(stderr,"Error: malloc\n");
                exit (1);
        }

        /* Read file in allocated space */
        if ((c = fread(buf, 1, *size, fp)) != *size) {
                fprintf(stderr,"Error: fread\n");
                exit (1);
        }
        fclose(fp);
        return (buf);
}

//Generate a random number of heuristic passes
int 
get_passes()
{
	int passes;
	srand (time(NULL));
	passes = ((rand() % 100) +5);//generate number of passes between 5 and 105
	return passes;
}

//Retrieves the offsets of two sections
int * 
get_offsets (char* fileStr, char* section1, char* section2)
{
	FILE *pOutput;
	int i = 0;
	char CommandStr1[100 + sizeof(fileStr)];
	char CommandStr2[100 + sizeof(fileStr)];
	char outputStr[300];
	char *sections1[5];
	char *sections2[5];
	char delimiter[] = " ";
	int *offsets = malloc(8);
	
	strcpy(CommandStr1, "readelf -S ");
	strcat(CommandStr1, fileStr);
	strcat(CommandStr1, " | grep ");
    strcat(CommandStr1, section1);
	pOutput = popen(CommandStr1, "r");//Run the first command string to get first section offset

	fgets(outputStr, sizeof(outputStr), pOutput);//Retrieve output of command run
	char *pStrtok = strtok(outputStr, delimiter);//Split command output using " " delimiter
	
	while (pStrtok != NULL)//Iterate through string tokens appending each to sections1
	{
		sections1[i] = pStrtok;
		pStrtok = strtok(NULL, delimiter);	
		i = i + 1;
	}
	i = 0;

	offsets[0] = (int)strtol(sections1[4], NULL, 16);//Store the 4th element in the array of string tokens generated by strtok as the first offset
	
	
	strcpy(CommandStr2, "readelf -S ");
	strcat(CommandStr2, fileStr);
	strcat(CommandStr2, " | grep ");
    strcat(CommandStr2, section2);	
    
	pOutput = popen(CommandStr2, "r");
	
	fgets(outputStr, sizeof(outputStr), pOutput);
	pStrtok = strtok(outputStr, delimiter);
	
	while (pStrtok != NULL)
	{
		sections2[i] = pStrtok;
		pStrtok = strtok(NULL, delimiter); 
		i = i + 1;
	}
	offsets[1] = (int)strtol(sections2[4], NULL, 16); 
	
	return offsets;
}
                                                                                       
//Retrieves entrypoint of binary
int 
get_entrypoint(char *fileStr)
{
	FILE *pOutput;
	char command[23 + sizeof(fileStr)]; //hold command
	char outputStr[100];
	char entryPointStr[7];
	int entryPoint;
	int i;
	
	strcpy(command, "readelf -h ");
	strcat(command, fileStr);
	strcat(command, " | grep Entry");
	
	pOutput = popen(command, "r");
	fgets(outputStr, sizeof(outputStr), pOutput);//place output of command in outputStr
	
	for (i=0; i < 7; i++)
	{
		entryPointStr[i] = outputStr[i + 37];
	}
	
	entryPoint = strtol(entryPointStr, NULL, 0);//Convert entrypoint str to a hex number
	
	return(entryPoint);
}

//Build encoder array
int 
main(int argc, char *argv[]) 
{
    //test_main();
	int encode_or_decode = 0, obf_end = 0, obf_class = 0, obf_section_typ = 0, obf_got = 0, obf_code = 0, valid_file = 0;//These values are all obfuscation options which can be specified in command line arguments
	char fileStr[256];
	unsigned char *flData;
	int i, size, passes = 0, entryPoint;
	FILE *pFile;
	int *offsets; 
	
	if(argc < 2){
		printf("Not enough arguments. See the obfuscation options below \n");
        printf("\n");
        printf("ENCODING OPTIONS \n");
        printf("-------------------\n");
        printf("e: Encode \n");
        printf("d: Decode \n");
        printf("h x: Generate x number of heuristic rounds \n");
        printf("hr: Generate random number of heuristic rounds \n");
        printf("\n");
        printf("HEADER MODIFICATION \n");
        printf("-------------------\n");
        printf("en: Endian obfuscation \n");
        printf("c: Class obfuscation \n");
        printf("st: Section type obfuscation \n");
        printf("\n");
        printf("GOT OBFUSCATION \n");
        printf("-------------------\n");
        printf("g: GOT obfuscation (target executable must be a no-pie)\n");
        printf("\n");
        printf("CODE LEVEL OBFUSCATION \n");        
        printf("-------------------\n");
        printf("code: Code level obfuscation \n");
        printf("\n");
        printf("Encoding obfuscation cannot be combined with endian or class obfuscation \n");
		exit(0);
	}
	
	for (i = 1; i < argc; i++)//loop through arguments, setting options to true if they appear
	{
		if( ! strcmp(argv[i], "en"))
			obf_end = 1;
		else if( ! strcmp(argv[i], "c"))
			obf_class = 1;
		else if( ! strcmp(argv[i], "st"))
			obf_section_typ = 1;
		else if( ! strcmp(argv[i], "e")){
            if(encode_or_decode == 2){
                printf("Decoding and Encoding cannot be combined \n");
                exit(0);
            }else{
                encode_or_decode = 1;
            }
        }
		else if( ! strcmp(argv[i], "d")){
            if(encode_or_decode == 1){
                printf("Decoding and Encoding cannot be combined \n");
                exit(0);
            }else{
                encode_or_decode = 2;
            }
        }
        else if( ! strcmp(argv[i], "g")){
            obf_got = 1;
        }
		else if( ! strcmp(argv[i], "h"))
			passes = atoi(argv[i + 1]);
        else if( ! strcmp(argv[i], "code")){
            obf_code = 1;
        }
		else if( ! strcmp(argv[i], "hr"))
		{
			passes = get_passes();
			
		}
	}

    if(encode_or_decode == 2 &&(obf_end == 1 || obf_class == 1|| obf_section_typ == 1|| obf_got == 1 || passes != 0)){
        printf("Decoding cannot be combined with obfuscation \n");
        exit(0);
    }
    else if (obf_code == 1 && (obf_class == 1 || obf_end == 1 || obf_section_typ == 1 || encode_or_decode != 0 || passes != 0)){
        printf("Binary obfuscation should be applied after code obfuscation \n");
        exit(0);
    }else if(encode_or_decode != 0 && (obf_class == 1 || obf_end == 1)){
        printf("Encoding obfuscation cannot be combined with endian or class obfuscation \n");
        exit(0);
    }else if(passes != 0 && encode_or_decode != 1){
        printf("Heuristic rounds must be combined with encoding \n");
        exit(0);
    }
	int heuristicSeq [passes];
	
	//ask user for file and loop until file is successfully opened
	while (valid_file == 0){
		printf("Enter a filename: \n");	
		scanf("%s", fileStr);
        if(obf_code == 1 && fileStr[strlen(fileStr) -1] != 'c'){
            printf("Code Obfuscation can only be performed on .c files \n");
        }else{
		    pFile = fopen(fileStr, "rb");
		    if (pFile == NULL){
			    printf("Error opening file %s\n", fileStr);
		    }
		    else
		    {
			    valid_file = 1;
		    }
        }
	}

	fseek(pFile, 0L, SEEK_END);
  	size = ftell(pFile);
	rewind(pFile);
	
	flData = read_file(&size, pFile);
	
        if (obf_code == 1){
            char *data_holder = (char *)malloc (sizeof(char)*(size));
            obfuscate_code(flData, size, fileStr, data_holder);
            free(data_holder);
        }
        else{
            entryPoint = get_entrypoint(fileStr);
			if (entryPoint == 0){
				printf("ERROR: File is not an elf binary. Exiting \n");
                exit(0);
			}
	        printf("Entrypoint: %.2x \n", entryPoint);

            offsets = get_offsets(fileStr, ".text", ".fini");
            int *encoder = (int *)malloc (sizeof(int)*(size)); // allocate space for encoder which will hold entire file
            if (obf_got == 1){
                printf("Invoking GOT obfuscation \n");
                obfuscate_got(flData, fileStr);
            }
	        if (obf_end == 1) 
	        {
		        printf("Flipping endian bits \n");
		        obfuscate_endianness(flData);
	        }
	        if (obf_class == 1) 
	        {
		        printf("Flipping architecture bits \n");
		        obfuscate_class(flData);
	        }
	        if (obf_section_typ == 1) 
	        {
		        printf("Overwriting section types \n");
		        obfuscate_section_type(flData, fileStr);
	        }
	        
	        if (encode_or_decode != 0)//1 = encode 2 = decode
		        buildencoder(encode_or_decode, size, offsets, flData, fileStr, encoder, 5, heuristicSeq, passes);
	        else{//if encode_or_decode = 0, no encoding option specified
		        buildencoder(encode_or_decode, size, offsets, flData, fileStr, encoder, 0, heuristicSeq, 0);
                //create_runner(size, offsets, flData);
            }
           free(encoder);
	       free(offsets);
        }
        free(flData);
}
